---

copyright:
  years: 2016, 2017
lastupdated: "2017-02-21"

---

{:shortdesc: .shortdesc}
{:new_window: target="_blank"}
{:codeblock: .codeblock}
{:screen: .screen}
{:pre: .pre}

# {{site.data.keyword.openwhisk_short}} の概要

{{site.data.keyword.openwhisk}} は、サーバーレス・コンピューティングまたは Function as a Service (FaaS) とも呼ばれるイベント・ドリブン計算プラットフォームであり、イベントまたは直接起動に応えてコードを実行します。次の図は、{{site.data.keyword.openwhisk}} アーキテクチャーの概要を示したものです。
{: shortdesc}

![{{site.data.keyword.openwhisk_short}} アーキテクチャー](./images/OpenWhisk.png)

イベントの例には、データベース・レコードへの変更、IoT センサーによる一定の気温を超えたことの感知、GitHub リポジトリーへの新規コードのコミット、Web アプリまたはモバイル・アプリからの単純な HTTP 要求などがあります。外部および内部のイベント・ソースからのイベントは、トリガーを通じてチャネル設定され、ルールによって許可されたアクションがこれらのイベントに対応します。

アクションは、JavaScript または Swift の小さなコード断片であるか、Docker コンテナーに組み込まれたカスタム・バイナリー・コードであることが可能です。{{site.data.keyword.openwhisk_short}} のアクションは、トリガーが発生するとすぐにデプロイされて実行されます。発生するトリガーが多いほど、起動されるアクションは多くなります。トリガーがまったく発生しない場合、実行されるアクション・コードはなく、したがってコストはかかりません。

アクションをトリガーと関連付けることに加えて、{{site.data.keyword.openwhisk_short}} API、CLI、または iOS SDK を使用することによってアクションを直接起動することも可能です。一連のアクションを、コードを何も書く必要なくチェーニングすることもできます。チェーン内の各アクションは順に起動され、あるアクションの出力は次のアクションへの入力として順に渡されていきます。

従来型の長時間稼働する仮想マシンまたはコンテナーを使用する場合、複数の VM またはコンテナーをデプロイして、1 つのインスタンスで障害が起こっても回復できるようにすることが一般的です。しかし、{{site.data.keyword.openwhisk_short}} はそれに代わるモデルとして、回復力に関連する余分なコストのないモデルを提供します。アクションがオンデマンドで実行されることにより、実行アクション数は常にトリガー率と一致するため、特有の拡張容易性および最良の使用効率がもたらされます。さらに、開発者はコードにのみ集中でき、モニターやパッチを気にしたり、基盤サーバー、ストレージ、ネットワーク、およびオペレーティング・システム・インフラストラクチャーの保護について考えたりする必要はありません。

さらに多くのサービスおよびイベント・プロバイダーとの統合をパッケージで追加することができます。パッケージとは、フィードおよびアクションを束ねたものです。フィードとは、外部イベント・ソースを構成してトリガー・イベントを発生させるコード断片です。例えば、Cloudant 変更フィードで作成されるトリガーは、文書が変更されるか Cloudant データベースに追加されるたびにそのトリガーが発生するようにサービスを構成します。パッケージ内のアクションは、再使用可能なロジックを表します。サービス・プロバイダーがアクションを利用可能にすることによって、開発者はそのサービスをイベント・ソースとして使用できるだけでなく、そのサービスの API を起動することもできます。

既存のパッケージ・カタログを利用すると、素早く簡単に、有用な機能でアプリケーションを強化したり、エコシステム内の外部サービスにアクセスしたりできます。{{site.data.keyword.openwhisk_short}} 対応の外部サービスの例として、Cloudant、The Weather Company、Slack、GitHub などがあります。


## {{site.data.keyword.openwhisk_short}} の動作
{: #openwhisk_how}

OpenWhisk は、オープン・ソースのプロジェクトであり、Nginx、Kafka、Consul、Docker、CouchDB などがベースになっています。これらすべてのコンポーネントが一緒になって 「サーバーレスのイベント・ベースのプログラミング・サービス」を形成しています。これらすべてのコンポーネントをもっと詳しく説明するため、このシステムでアクションの起動がどのように処理されていくのかをトレースしてみましょう。OpenWhisk における起動はサーバーレス・エンジンが行うことの核心部であり、ユーザーがシステムに送り込んだコードを実行し、その実行の結果を返します。

### アクションの作成

前後の状況が分かりやすい説明にするため、最初にシステム内にアクションを 1 つ作成します。後で、そのアクションを使用して、システムをたどりながら概念を説明します。以下に示すコマンドでは、[OpenWhisk CLI の適切なセットアップ](https://github.com/openwhisk/openwhisk/tree/master/docs#setting-up-the-openwhisk-cli)が行われていると想定しています。

最初に、以下のコードを含んでいるファイル *action.js* を作成します。これは、「Hello World」を stdout に出力し、キー「hello」で「world」を含んでいる JSON オブジェクトを返すコードです。
```javascript
function main() {
    console.log('Hello World');
    return { hello: 'world' };
}
```
{: codeblock}

以下を使用してこのアクションを作成します。
```
wsk action create myAction action.js
```
{: pre}

完了しました。 次に、実際にこのアクションを起動します。
```
wsk action invoke myAction
```
{: pre}

## 内部的な処理の流れ
それぞれの場面の背後で OpenWhisk では実際に何が起こっているのでしょうか?

![OpenWhisk 処理フロー](images/OpenWhisk_flow_of_processing.png)

### システムに入る: nginx

最初に: ユーザーに面している OpenWhisk の API は、完全に HTTP ベースであり、RESTful 設計に従っています。したがって、wsk-CLI を介して送信されるコマンドは、実質的には OpenWhisk システムに対する HTTP 要求です。上記の特定のコマンドは、おおよそ次のように変換されます。
```
POST /api/v1/namespaces/$userNamespace/actions/myAction
Host: $openwhiskEndpoint
```
{: screen}

ここで *$userNamespace* 変数に注意してください。1 人のユーザーは少なくとも 1 つの名前空間にアクセスできます。単純化するため、*myAction* が入れられた名前空間をユーザーが所有していると想定しましょう。

システムへの最初のエントリー・ポイントは、HTTP およびリバース・プロキシー・サーバーである **nginx** を通るものです。これは主として、SSL 終端処理のためと、適切な HTTP 呼び出しを次のコンポーネントに転送するために使用されます。

### システムに入る: Controller

nginx は、HTTP 要求に対してあまり多くのことを行うことなく、それを **Controller** に送ります。OpenWhisk 全体にわたるこの説明で次に扱うのがこのコンポーネントです。これは、実際の REST API の Scala ベースの実装であり (**Akka** および **Spray** に基づく)、したがって、OpenWhisk 内のエンティティーに対する [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) 要求や、アクションの起動 (まさに今から行おうとしていること) を含めて、ユーザーが実行できるすべてのことに対するインターフェースとして機能します。

Controller は、最初に、ユーザーが行おうとしていることのあいまいさを解消します。これは HTTP 要求内で使用される HTTP メソッドに基づいて行われます。上記の変換で示されているように、ユーザーは既存アクションに POST 要求を発行しようとしています。Controller はこれを**アクションの起動**に変換します。

Controller の中心的役割 (この名前の由来) を考えると、Controller は以下のすべてのステップにある程度関与します。

### 認証および許可: CouchDB

次に、Controller は、ユーザーが誰なのかを検証 (*認証*) し、そのエンティティーで実行しようとしていることを行う特権をユーザーが持っているかどうかを検証 (*許可*) します。要求に組み込まれている資格情報が、**CouchDB** インスタンス内のいわゆる**サブジェクト**・データベースに照らして検証されます。

この例では、ユーザーが OpenWhisk のデータベースに存在することと、myAction アクションを起動する特権を持っていることが検査されます。このアクションはユーザーが所有する名前空間にあるアクションであると想定されているため、ユーザーには望み通りにこのアクションを起動する特権が効率的に付与されます。

すべてが正常に進んでいるため、次の処理ステージへのゲートが開きます。

### アクションを取得する: もう一度 CouchDB

Controller は、ユーザーがアクションを起動するための許可と特権を持っていることを確認できたので、このアクション (この例では *myAction*) を CouchDB 内の **whisks** データベースから実際にロードします。

アクションのレコードに主として含まれるのは、実行するコード (上記) と、アクションに渡すデフォルト・パラメーターです (実際の起動要求に組み込んだパラメーターとマージされます)。また、実行時に課されるリソース制限 (例えば、消費が許可されるメモリー量) も含まれます。

この特定の例で使用しているアクションにはパラメーターはありません (関数のパラメーター定義は空リストです)。したがって、設定したデフォルト・パラメーターはなく、アクションに送信した特定のパラメーターもないと想定され、この観点からすると最も簡単な例となっています。

### アクションを起動するために何がいるのか: Consul

この時点で、Controller (具体的には、そのロード・バランシング部分) では、実際にコードを実行するために必要なすべてが揃っています。ただし、実行のために何が使用可能なのかを知る必要があります。
サービス・ディスカバリー **Consul** が使用されて、システムで使用可能な実行プログラムが、継続的にその正常性状況をチェックすることによってトラッキングされます。
それらの実行プログラムを **Invoker** と呼びます。

Controller は、どの Invoker が使用可能なのかを認識し、その中から、要求されたアクションを起動する Invoker を 1 個選択します。

この例では、システムで使用可能な Invoker は 3 個 (Invoker 0 から 2) あり、手元にあるアクションを起動するよう Controller が *Invoker 2* を選択したと想定しましょう。

### 整列させる: Kafka

これ以降、送信した起動要求に関して起こり得る望ましくない事態として、主に次の 2 つが考えられます。

1. システムがクラッシュして起動が失われる可能性があります。
2. まず他の起動が完了するのを待機しなければならないような重い負荷がシステムにかかる可能性があります。

両方に対する解答が、高スループットの分散パブリッシュ/サブスクライブ・メッセージング・システムである **Kafka** です。Controller と Invoker は、Kafka によってバッファーに入れられて永続化されるメッセージを介してのみ通信します。これにより、*OutOfMemoryException* のリスクがあるメモリー内でのバッファリングという負担から Controller と Invoker の両方が解放され、システムがクラッシュしてもメッセージが失われないことも確実になります。

次に、アクションが起動されるように Controller は Kafka にメッセージをパブリッシュします。そのメッセージには、起動するアクションと、そのアクションに渡すパラメーター (この例ではパラメーターはありません) が含まれます。このメッセージの宛先は、上で Controller が Consul から取得したリストから選択した Invoker です。

Kafka がメッセージを取得したことを確認すると、ユーザーへの HTTP 要求は **ActivationId** を伴って応答されます。ユーザーは後でそれを使用して、この特定の起動の結果にアクセスします。これは非同期起動モデルであることに注意してください。このモデルでは、HTTP 要求はアクションを起動する要求をシステムが受け入れたら終了します。同期モデル (ブロッキング起動と呼ばれます) も使用可能ですが、この記事ではカバーしていません。

### 既に実際にコードを起動する: Invoker

**Invoker** は OpenWhisk の中心です。Invoker の義務は、アクションを起動することです。これは Scala でも実装されています。しかし、これにはそれ以上のものがあります。隔離された安全な方法でアクションを実行するため、**Docker** が使用されています。

Docker の使用によって、隔離され制御された方法で素早くアクションが実行されるよう、起動するアクションごとに自己包含環境 (*コンテナー* と呼ばれます) が新しくセットアップされます。簡潔に説明すると、アクション起動ごとに 1 つの Docker コンテナーが作成され、アクション・コードが注入され、渡されたパラメーターを使用して実行され、結果が取得され、コンテナーが破棄されます。これは、オーバーヘッドを減らして応答時間をできるだけ短くするために多くのパフォーマンス最適化が行われる場所でもあります。 

ここで使用している特定の例では、*Node.js* ベースのアクションが手元にあるため、Invoker は Node.js コンテナーを開始し、*myAction* からコードを注入し、パラメーターなしで実行し、結果を抽出し、ログを保存し、再び Node.js コンテナーを破棄します。

### 結果を保管する: もう一度 CouchDB

結果が Invoker によって取得されると、結果は **whisks** データベースに、上で説明した ActivationID の下でアクティベーションとして保管されます。**whisks** データベースは **CouchDB** 内にあります。

ここで使用している特定の例では、Invoker は結果の JSON オブジェクトをアクションから返され、Docker によって書き込まれたログを取得し、それらをすべてアクティベーション・レコードに入れ、そのレコードをデータベースに保管します。そのレコードは以下のようなものです。

```json
{
   "activationId": "31809ddca6f64cfc9de2937ebd44fbb9",
   "response": {
       "statusCode": 0,
       "result": {
           "hello": "world"
       }
   },
   "end": 1474459415621,
   "logs": [
       "2016-09-21T12:03:35.619234386Z stdout: Hello World"
   ],
   "start": 1474459415595,
}
```
{: codeblock}

返された結果と書き込まれたログの両方がどのようにレコードに含まれているのかに注意してください。アクション起動の開始時刻と終了時刻も含まれています。アクティベーション・レコードには他のフィールドもありますが、簡単にするため上記の例では省略されています。

ここでもう一度 REST API を使用して (再びステップ 1 から開始する)、アクティベーションを取得でき、したがってアクションの結果を取得できます。それを行うには、以下を使用します。

```bash
wsk activation get 31809ddca6f64cfc9de2937ebd44fbb9
```
{: pre} 

### サマリー

単純な **wsk action invoke myAction** がどのように {{site.data.keyword.openwhisk_short}} システムのさまざまなステージを通過していくのかを見てきました。システム自体は、主に 2 つのみのカスタム・コンポーネント、**Controller** と **Invoker** からなります。
他のすべては、オープン・ソース・コミュニティーの多くの人によって開発され、既に存在しています。

{{site.data.keyword.openwhisk_short}} に関する追加情報が以下のトピックに記載されています。

* [エンティティー名](./openwhisk_reference.html#openwhisk_entities)
* [アクションの意味](./openwhisk_reference.html#openwhisk_semantics)
* [制限](./openwhisk_reference.md#openwhisk_syslimits)
* [REST API](./openwhisk_reference.md#openwhisk_ref_restapi)
